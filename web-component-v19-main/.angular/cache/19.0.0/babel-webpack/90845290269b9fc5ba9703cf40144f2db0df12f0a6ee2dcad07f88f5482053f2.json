{"ast":null,"code":"/**\n * @license Angular v19.0.0\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ComponentFactoryResolver, NgZone, ApplicationRef, ɵChangeDetectionScheduler, Injector, Version } from '@angular/core';\nimport { ReplaySubject, merge, Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n/**\n * Provide methods for scheduling the execution of a callback.\n */\nconst scheduler = {\n  /**\n   * Schedule a callback to be called after some delay.\n   *\n   * Returns a function that when executed will cancel the scheduled function.\n   */\n  schedule(taskFn, delay) {\n    const id = setTimeout(taskFn, delay);\n    return () => clearTimeout(id);\n  }\n};\n/**\n * Convert a camelCased string to kebab-cased.\n */\nfunction camelToDashCase(input) {\n  return input.replace(/[A-Z]/g, char => `-${char.toLowerCase()}`);\n}\n/**\n * Check whether the input is an `Element`.\n */\nfunction isElement(node) {\n  return !!node && node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Check whether the input is a function.\n */\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * Convert a kebab-cased string to camelCased.\n */\nfunction kebabToCamelCase(input) {\n  return input.replace(/-([a-z\\d])/g, (_, char) => char.toUpperCase());\n}\nlet _matches;\n/**\n * Check whether an `Element` matches a CSS selector.\n * NOTE: this is duplicated from @angular/upgrade, and can\n * be consolidated in the future\n */\nfunction matchesSelector(el, selector) {\n  if (!_matches) {\n    const elProto = Element.prototype;\n    _matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector;\n  }\n  return el.nodeType === Node.ELEMENT_NODE ? _matches.call(el, selector) : false;\n}\n/**\n * Test two values for strict equality, accounting for the fact that `NaN !== NaN`.\n */\nfunction strictEquals(value1, value2) {\n  return value1 === value2 || value1 !== value1 && value2 !== value2;\n}\n/** Gets a map of default set of attributes to observe and the properties they affect. */\nfunction getDefaultAttributeToPropertyInputs(inputs) {\n  const attributeToPropertyInputs = {};\n  inputs.forEach(({\n    propName,\n    templateName,\n    transform\n  }) => {\n    attributeToPropertyInputs[camelToDashCase(templateName)] = [propName, transform];\n  });\n  return attributeToPropertyInputs;\n}\n/**\n * Gets a component's set of inputs. Uses the injector to get the component factory where the inputs\n * are defined.\n */\nfunction getComponentInputs(component, injector) {\n  const componentFactoryResolver = injector.get(ComponentFactoryResolver);\n  const componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n  return componentFactory.inputs;\n}\n\n// NOTE: This is a (slightly improved) version of what is used in ngUpgrade's\nfunction extractProjectableNodes(host, ngContentSelectors) {\n  const nodes = host.childNodes;\n  const projectableNodes = ngContentSelectors.map(() => []);\n  let wildcardIndex = -1;\n  ngContentSelectors.some((selector, i) => {\n    if (selector === '*') {\n      wildcardIndex = i;\n      return true;\n    }\n    return false;\n  });\n  for (let i = 0, ii = nodes.length; i < ii; ++i) {\n    const node = nodes[i];\n    const ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);\n    if (ngContentIndex !== -1) {\n      projectableNodes[ngContentIndex].push(node);\n    }\n  }\n  return projectableNodes;\n}\nfunction findMatchingIndex(node, selectors, defaultIndex) {\n  let matchingIndex = defaultIndex;\n  if (isElement(node)) {\n    selectors.some((selector, i) => {\n      if (selector !== '*' && matchesSelector(node, selector)) {\n        matchingIndex = i;\n        return true;\n      }\n      return false;\n    });\n  }\n  return matchingIndex;\n}\n\n/** Time in milliseconds to wait before destroying the component ref when disconnected. */\nconst DESTROY_DELAY = 10;\n/**\n * Factory that creates new ComponentNgElementStrategy instance. Gets the component factory with the\n * constructor's injector's factory resolver and passes that factory to each strategy.\n */\nclass ComponentNgElementStrategyFactory {\n  componentFactory;\n  inputMap = /*#__PURE__*/new Map();\n  constructor(component, injector) {\n    this.componentFactory = injector.get(ComponentFactoryResolver).resolveComponentFactory(component);\n    for (const input of this.componentFactory.inputs) {\n      this.inputMap.set(input.propName, input.templateName);\n    }\n  }\n  create(injector) {\n    return new ComponentNgElementStrategy(this.componentFactory, injector, this.inputMap);\n  }\n}\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n */\nclass ComponentNgElementStrategy {\n  componentFactory;\n  injector;\n  inputMap;\n  // Subject of `NgElementStrategyEvent` observables corresponding to the component's outputs.\n  eventEmitters = /*#__PURE__*/new ReplaySubject(1);\n  /** Merged stream of the component's output events. */\n  events = /*#__PURE__*/this.eventEmitters.pipe(/*#__PURE__*/switchMap(emitters => merge(...emitters)));\n  /** Reference to the component that was created on connect. */\n  componentRef = null;\n  /** Callback function that when called will cancel a scheduled destruction on the component. */\n  scheduledDestroyFn = null;\n  /** Initial input values that were set before the component was created. */\n  initialInputValues = /*#__PURE__*/new Map();\n  /** Service for setting zone context. */\n  ngZone;\n  /** The zone the element was created in or `null` if Zone.js is not loaded. */\n  elementZone;\n  /**\n   * The `ApplicationRef` shared by all instances of this custom element (and potentially others).\n   */\n  appRef;\n  /**\n   * Angular's change detection scheduler, which works independently of zone.js.\n   */\n  cdScheduler;\n  constructor(componentFactory, injector, inputMap) {\n    this.componentFactory = componentFactory;\n    this.injector = injector;\n    this.inputMap = inputMap;\n    this.ngZone = this.injector.get(NgZone);\n    this.appRef = this.injector.get(ApplicationRef);\n    this.cdScheduler = injector.get(ɵChangeDetectionScheduler);\n    this.elementZone = typeof Zone === 'undefined' ? null : this.ngZone.run(() => Zone.current);\n  }\n  /**\n   * Initializes a new component if one has not yet been created and cancels any scheduled\n   * destruction.\n   */\n  connect(element) {\n    this.runInZone(() => {\n      // If the element is marked to be destroyed, cancel the task since the component was\n      // reconnected\n      if (this.scheduledDestroyFn !== null) {\n        this.scheduledDestroyFn();\n        this.scheduledDestroyFn = null;\n        return;\n      }\n      if (this.componentRef === null) {\n        this.initializeComponent(element);\n      }\n    });\n  }\n  /**\n   * Schedules the component to be destroyed after some small delay in case the element is just\n   * being moved across the DOM.\n   */\n  disconnect() {\n    this.runInZone(() => {\n      // Return if there is no componentRef or the component is already scheduled for destruction\n      if (this.componentRef === null || this.scheduledDestroyFn !== null) {\n        return;\n      }\n      // Schedule the component to be destroyed after a small timeout in case it is being\n      // moved elsewhere in the DOM\n      this.scheduledDestroyFn = scheduler.schedule(() => {\n        if (this.componentRef !== null) {\n          this.componentRef.destroy();\n          this.componentRef = null;\n        }\n      }, DESTROY_DELAY);\n    });\n  }\n  /**\n   * Returns the component property value. If the component has not yet been created, the value is\n   * retrieved from the cached initialization values.\n   */\n  getInputValue(property) {\n    return this.runInZone(() => {\n      if (this.componentRef === null) {\n        return this.initialInputValues.get(property);\n      }\n      return this.componentRef.instance[property];\n    });\n  }\n  /**\n   * Sets the input value for the property. If the component has not yet been created, the value is\n   * cached and set when the component is created.\n   */\n  setInputValue(property, value) {\n    if (this.componentRef === null) {\n      this.initialInputValues.set(property, value);\n      return;\n    }\n    this.runInZone(() => {\n      this.componentRef.setInput(this.inputMap.get(property) ?? property, value);\n      // `setInput` won't mark the view dirty if the input didn't change from its previous value.\n      if (this.componentRef.hostView.dirty) {\n        // `setInput` will have marked the view dirty already, but also mark it for refresh. This\n        // guarantees the view will be checked even if the input is being set from within change\n        // detection. This provides backwards compatibility, since we used to unconditionally\n        // schedule change detection in addition to the current zone run.\n        this.componentRef.changeDetectorRef.markForRefresh();\n        // Notifying the scheduler with `NotificationSource.CustomElement` causes a `tick()` to be\n        // scheduled unconditionally, even if the scheduler is otherwise disabled.\n        this.cdScheduler.notify(6 /* NotificationSource.CustomElement */);\n      }\n    });\n  }\n  /**\n   * Creates a new component through the component factory with the provided element host and\n   * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n   */\n  initializeComponent(element) {\n    const childInjector = Injector.create({\n      providers: [],\n      parent: this.injector\n    });\n    const projectableNodes = extractProjectableNodes(element, this.componentFactory.ngContentSelectors);\n    this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n    this.initializeInputs();\n    this.initializeOutputs(this.componentRef);\n    this.appRef.attachView(this.componentRef.hostView);\n    this.componentRef.hostView.detectChanges();\n  }\n  /** Set any stored initial inputs on the component's properties. */\n  initializeInputs() {\n    for (const [propName, value] of this.initialInputValues) {\n      this.setInputValue(propName, value);\n    }\n    this.initialInputValues.clear();\n  }\n  /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n  initializeOutputs(componentRef) {\n    const eventEmitters = this.componentFactory.outputs.map(({\n      propName,\n      templateName\n    }) => {\n      const emitter = componentRef.instance[propName];\n      return new Observable(observer => {\n        const sub = emitter.subscribe(value => observer.next({\n          name: templateName,\n          value\n        }));\n        return () => sub.unsubscribe();\n      });\n    });\n    this.eventEmitters.next(eventEmitters);\n  }\n  /** Runs in the angular zone, if present. */\n  runInZone(fn) {\n    return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(fn) : fn();\n  }\n}\n\n/**\n * Implements the functionality needed for a custom element.\n *\n * @publicApi\n */\nclass NgElement extends HTMLElement {\n  /**\n   * A subscription to change, connect, and disconnect events in the custom element.\n   */\n  ngElementEventsSubscription = null;\n}\n/**\n *  @description Creates a custom element class based on an Angular component.\n *\n * Builds a class that encapsulates the functionality of the provided component and\n * uses the configuration information to provide more context to the class.\n * Takes the component factory's inputs and outputs to convert them to the proper\n * custom element API and add hooks to input changes.\n *\n * The configuration's injector is the initial injector set on the class,\n * and used by default for each created instance.This behavior can be overridden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations.\n *\n * @see [Angular Elements Overview](guide/elements \"Turning Angular components into custom elements\")\n *\n * @param component The component to transform.\n * @param config A configuration that provides initialization information to the created class.\n * @returns The custom-element construction class, which can be registered with\n * a browser's `CustomElementRegistry`.\n *\n * @publicApi\n */\nfunction createCustomElement(component, config) {\n  const inputs = getComponentInputs(component, config.injector);\n  const strategyFactory = config.strategyFactory || new ComponentNgElementStrategyFactory(component, config.injector);\n  const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);\n  class NgElementImpl extends NgElement {\n    injector;\n    // Work around a bug in closure typed optimizations(b/79557487) where it is not honoring static\n    // field externs. So using quoted access to explicitly prevent renaming.\n    static ['observedAttributes'] = Object.keys(attributeToPropertyInputs);\n    get ngElementStrategy() {\n      // TODO(andrewseguin): Add e2e tests that cover cases where the constructor isn't called. For\n      // now this is tested using a Google internal test suite.\n      if (!this._ngElementStrategy) {\n        const strategy = this._ngElementStrategy = strategyFactory.create(this.injector || config.injector);\n        // Re-apply pre-existing input values (set as properties on the element) through the\n        // strategy.\n        // TODO(alxhub): why are we doing this? this makes no sense.\n        inputs.forEach(({\n          propName,\n          transform,\n          isSignal\n        }) => {\n          if (!this.hasOwnProperty(propName) || isSignal) {\n            // No pre-existing value for `propName`, or a signal input.\n            return;\n          }\n          // Delete the property from the instance and re-apply it through the strategy.\n          const value = this[propName];\n          delete this[propName];\n          strategy.setInputValue(propName, value, transform);\n        });\n      }\n      return this._ngElementStrategy;\n    }\n    _ngElementStrategy;\n    constructor(injector) {\n      super();\n      this.injector = injector;\n    }\n    attributeChangedCallback(attrName, oldValue, newValue, namespace) {\n      const [propName, transform] = attributeToPropertyInputs[attrName];\n      this.ngElementStrategy.setInputValue(propName, newValue, transform);\n    }\n    connectedCallback() {\n      // For historical reasons, some strategies may not have initialized the `events` property\n      // until after `connect()` is run. Subscribe to `events` if it is available before running\n      // `connect()` (in order to capture events emitted during initialization), otherwise subscribe\n      // afterwards.\n      //\n      // TODO: Consider deprecating/removing the post-connect subscription in a future major version\n      //       (e.g. v11).\n      let subscribedToEvents = false;\n      if (this.ngElementStrategy.events) {\n        // `events` are already available: Subscribe to it asap.\n        this.subscribeToEvents();\n        subscribedToEvents = true;\n      }\n      this.ngElementStrategy.connect(this);\n      if (!subscribedToEvents) {\n        // `events` were not initialized before running `connect()`: Subscribe to them now.\n        // The events emitted during the component initialization have been missed, but at least\n        // future events will be captured.\n        this.subscribeToEvents();\n      }\n    }\n    disconnectedCallback() {\n      // Not using `this.ngElementStrategy` to avoid unnecessarily creating the `NgElementStrategy`.\n      if (this._ngElementStrategy) {\n        this._ngElementStrategy.disconnect();\n      }\n      if (this.ngElementEventsSubscription) {\n        this.ngElementEventsSubscription.unsubscribe();\n        this.ngElementEventsSubscription = null;\n      }\n    }\n    subscribeToEvents() {\n      // Listen for events from the strategy and dispatch them as custom events.\n      this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(e => {\n        const customEvent = new CustomEvent(e.name, {\n          detail: e.value\n        });\n        this.dispatchEvent(customEvent);\n      });\n    }\n  }\n  // Add getters and setters to the prototype for each property input.\n  inputs.forEach(({\n    propName,\n    transform\n  }) => {\n    Object.defineProperty(NgElementImpl.prototype, propName, {\n      get() {\n        return this.ngElementStrategy.getInputValue(propName);\n      },\n      set(newValue) {\n        this.ngElementStrategy.setInputValue(propName, newValue, transform);\n      },\n      configurable: true,\n      enumerable: true\n    });\n  });\n  return NgElementImpl;\n}\n\n/**\n * @publicApi\n */\nconst VERSION = /*#__PURE__*/new Version('19.0.0');\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the `elements` package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgElement, VERSION, createCustomElement };","map":{"version":3,"names":["ComponentFactoryResolver","NgZone","ApplicationRef","ɵChangeDetectionScheduler","Injector","Version","ReplaySubject","merge","Observable","switchMap","scheduler","schedule","taskFn","delay","id","setTimeout","clearTimeout","camelToDashCase","input","replace","char","toLowerCase","isElement","node","nodeType","Node","ELEMENT_NODE","isFunction","value","kebabToCamelCase","_","toUpperCase","_matches","matchesSelector","el","selector","elProto","Element","prototype","matches","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","call","strictEquals","value1","value2","getDefaultAttributeToPropertyInputs","inputs","attributeToPropertyInputs","forEach","propName","templateName","transform","getComponentInputs","component","injector","componentFactoryResolver","get","componentFactory","resolveComponentFactory","extractProjectableNodes","host","ngContentSelectors","nodes","childNodes","projectableNodes","map","wildcardIndex","some","i","ii","length","ngContentIndex","findMatchingIndex","push","selectors","defaultIndex","matchingIndex","DESTROY_DELAY","ComponentNgElementStrategyFactory","inputMap","Map","constructor","set","create","ComponentNgElementStrategy","eventEmitters","events","pipe","emitters","componentRef","scheduledDestroyFn","initialInputValues","ngZone","elementZone","appRef","cdScheduler","Zone","run","current","connect","element","runInZone","initializeComponent","disconnect","destroy","getInputValue","property","instance","setInputValue","setInput","hostView","dirty","changeDetectorRef","markForRefresh","notify","childInjector","providers","parent","initializeInputs","initializeOutputs","attachView","detectChanges","clear","outputs","emitter","observer","sub","subscribe","next","name","unsubscribe","fn","NgElement","HTMLElement","ngElementEventsSubscription","createCustomElement","config","strategyFactory","NgElementImpl","Object","keys","ngElementStrategy","_ngElementStrategy","strategy","isSignal","hasOwnProperty","attributeChangedCallback","attrName","oldValue","newValue","namespace","connectedCallback","subscribedToEvents","subscribeToEvents","disconnectedCallback","e","customEvent","CustomEvent","detail","dispatchEvent","defineProperty","configurable","enumerable","VERSION"],"sources":["D:/pb/angular-element/web-component-v19-main/node_modules/@angular/elements/fesm2022/elements.mjs"],"sourcesContent":["/**\n * @license Angular v19.0.0\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ComponentFactoryResolver, NgZone, ApplicationRef, ɵChangeDetectionScheduler, Injector, Version } from '@angular/core';\nimport { ReplaySubject, merge, Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n/**\n * Provide methods for scheduling the execution of a callback.\n */\nconst scheduler = {\n    /**\n     * Schedule a callback to be called after some delay.\n     *\n     * Returns a function that when executed will cancel the scheduled function.\n     */\n    schedule(taskFn, delay) {\n        const id = setTimeout(taskFn, delay);\n        return () => clearTimeout(id);\n    },\n};\n/**\n * Convert a camelCased string to kebab-cased.\n */\nfunction camelToDashCase(input) {\n    return input.replace(/[A-Z]/g, (char) => `-${char.toLowerCase()}`);\n}\n/**\n * Check whether the input is an `Element`.\n */\nfunction isElement(node) {\n    return !!node && node.nodeType === Node.ELEMENT_NODE;\n}\n/**\n * Check whether the input is a function.\n */\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n/**\n * Convert a kebab-cased string to camelCased.\n */\nfunction kebabToCamelCase(input) {\n    return input.replace(/-([a-z\\d])/g, (_, char) => char.toUpperCase());\n}\nlet _matches;\n/**\n * Check whether an `Element` matches a CSS selector.\n * NOTE: this is duplicated from @angular/upgrade, and can\n * be consolidated in the future\n */\nfunction matchesSelector(el, selector) {\n    if (!_matches) {\n        const elProto = Element.prototype;\n        _matches =\n            elProto.matches ||\n                elProto.matchesSelector ||\n                elProto.mozMatchesSelector ||\n                elProto.msMatchesSelector ||\n                elProto.oMatchesSelector ||\n                elProto.webkitMatchesSelector;\n    }\n    return el.nodeType === Node.ELEMENT_NODE ? _matches.call(el, selector) : false;\n}\n/**\n * Test two values for strict equality, accounting for the fact that `NaN !== NaN`.\n */\nfunction strictEquals(value1, value2) {\n    return value1 === value2 || (value1 !== value1 && value2 !== value2);\n}\n/** Gets a map of default set of attributes to observe and the properties they affect. */\nfunction getDefaultAttributeToPropertyInputs(inputs) {\n    const attributeToPropertyInputs = {};\n    inputs.forEach(({ propName, templateName, transform }) => {\n        attributeToPropertyInputs[camelToDashCase(templateName)] = [propName, transform];\n    });\n    return attributeToPropertyInputs;\n}\n/**\n * Gets a component's set of inputs. Uses the injector to get the component factory where the inputs\n * are defined.\n */\nfunction getComponentInputs(component, injector) {\n    const componentFactoryResolver = injector.get(ComponentFactoryResolver);\n    const componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n    return componentFactory.inputs;\n}\n\n// NOTE: This is a (slightly improved) version of what is used in ngUpgrade's\nfunction extractProjectableNodes(host, ngContentSelectors) {\n    const nodes = host.childNodes;\n    const projectableNodes = ngContentSelectors.map(() => []);\n    let wildcardIndex = -1;\n    ngContentSelectors.some((selector, i) => {\n        if (selector === '*') {\n            wildcardIndex = i;\n            return true;\n        }\n        return false;\n    });\n    for (let i = 0, ii = nodes.length; i < ii; ++i) {\n        const node = nodes[i];\n        const ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);\n        if (ngContentIndex !== -1) {\n            projectableNodes[ngContentIndex].push(node);\n        }\n    }\n    return projectableNodes;\n}\nfunction findMatchingIndex(node, selectors, defaultIndex) {\n    let matchingIndex = defaultIndex;\n    if (isElement(node)) {\n        selectors.some((selector, i) => {\n            if (selector !== '*' && matchesSelector(node, selector)) {\n                matchingIndex = i;\n                return true;\n            }\n            return false;\n        });\n    }\n    return matchingIndex;\n}\n\n/** Time in milliseconds to wait before destroying the component ref when disconnected. */\nconst DESTROY_DELAY = 10;\n/**\n * Factory that creates new ComponentNgElementStrategy instance. Gets the component factory with the\n * constructor's injector's factory resolver and passes that factory to each strategy.\n */\nclass ComponentNgElementStrategyFactory {\n    componentFactory;\n    inputMap = new Map();\n    constructor(component, injector) {\n        this.componentFactory = injector\n            .get(ComponentFactoryResolver)\n            .resolveComponentFactory(component);\n        for (const input of this.componentFactory.inputs) {\n            this.inputMap.set(input.propName, input.templateName);\n        }\n    }\n    create(injector) {\n        return new ComponentNgElementStrategy(this.componentFactory, injector, this.inputMap);\n    }\n}\n/**\n * Creates and destroys a component ref using a component factory and handles change detection\n * in response to input changes.\n */\nclass ComponentNgElementStrategy {\n    componentFactory;\n    injector;\n    inputMap;\n    // Subject of `NgElementStrategyEvent` observables corresponding to the component's outputs.\n    eventEmitters = new ReplaySubject(1);\n    /** Merged stream of the component's output events. */\n    events = this.eventEmitters.pipe(switchMap((emitters) => merge(...emitters)));\n    /** Reference to the component that was created on connect. */\n    componentRef = null;\n    /** Callback function that when called will cancel a scheduled destruction on the component. */\n    scheduledDestroyFn = null;\n    /** Initial input values that were set before the component was created. */\n    initialInputValues = new Map();\n    /** Service for setting zone context. */\n    ngZone;\n    /** The zone the element was created in or `null` if Zone.js is not loaded. */\n    elementZone;\n    /**\n     * The `ApplicationRef` shared by all instances of this custom element (and potentially others).\n     */\n    appRef;\n    /**\n     * Angular's change detection scheduler, which works independently of zone.js.\n     */\n    cdScheduler;\n    constructor(componentFactory, injector, inputMap) {\n        this.componentFactory = componentFactory;\n        this.injector = injector;\n        this.inputMap = inputMap;\n        this.ngZone = this.injector.get(NgZone);\n        this.appRef = this.injector.get(ApplicationRef);\n        this.cdScheduler = injector.get(ɵChangeDetectionScheduler);\n        this.elementZone = typeof Zone === 'undefined' ? null : this.ngZone.run(() => Zone.current);\n    }\n    /**\n     * Initializes a new component if one has not yet been created and cancels any scheduled\n     * destruction.\n     */\n    connect(element) {\n        this.runInZone(() => {\n            // If the element is marked to be destroyed, cancel the task since the component was\n            // reconnected\n            if (this.scheduledDestroyFn !== null) {\n                this.scheduledDestroyFn();\n                this.scheduledDestroyFn = null;\n                return;\n            }\n            if (this.componentRef === null) {\n                this.initializeComponent(element);\n            }\n        });\n    }\n    /**\n     * Schedules the component to be destroyed after some small delay in case the element is just\n     * being moved across the DOM.\n     */\n    disconnect() {\n        this.runInZone(() => {\n            // Return if there is no componentRef or the component is already scheduled for destruction\n            if (this.componentRef === null || this.scheduledDestroyFn !== null) {\n                return;\n            }\n            // Schedule the component to be destroyed after a small timeout in case it is being\n            // moved elsewhere in the DOM\n            this.scheduledDestroyFn = scheduler.schedule(() => {\n                if (this.componentRef !== null) {\n                    this.componentRef.destroy();\n                    this.componentRef = null;\n                }\n            }, DESTROY_DELAY);\n        });\n    }\n    /**\n     * Returns the component property value. If the component has not yet been created, the value is\n     * retrieved from the cached initialization values.\n     */\n    getInputValue(property) {\n        return this.runInZone(() => {\n            if (this.componentRef === null) {\n                return this.initialInputValues.get(property);\n            }\n            return this.componentRef.instance[property];\n        });\n    }\n    /**\n     * Sets the input value for the property. If the component has not yet been created, the value is\n     * cached and set when the component is created.\n     */\n    setInputValue(property, value) {\n        if (this.componentRef === null) {\n            this.initialInputValues.set(property, value);\n            return;\n        }\n        this.runInZone(() => {\n            this.componentRef.setInput(this.inputMap.get(property) ?? property, value);\n            // `setInput` won't mark the view dirty if the input didn't change from its previous value.\n            if (this.componentRef.hostView.dirty) {\n                // `setInput` will have marked the view dirty already, but also mark it for refresh. This\n                // guarantees the view will be checked even if the input is being set from within change\n                // detection. This provides backwards compatibility, since we used to unconditionally\n                // schedule change detection in addition to the current zone run.\n                this.componentRef.changeDetectorRef.markForRefresh();\n                // Notifying the scheduler with `NotificationSource.CustomElement` causes a `tick()` to be\n                // scheduled unconditionally, even if the scheduler is otherwise disabled.\n                this.cdScheduler.notify(6 /* NotificationSource.CustomElement */);\n            }\n        });\n    }\n    /**\n     * Creates a new component through the component factory with the provided element host and\n     * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.\n     */\n    initializeComponent(element) {\n        const childInjector = Injector.create({ providers: [], parent: this.injector });\n        const projectableNodes = extractProjectableNodes(element, this.componentFactory.ngContentSelectors);\n        this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element);\n        this.initializeInputs();\n        this.initializeOutputs(this.componentRef);\n        this.appRef.attachView(this.componentRef.hostView);\n        this.componentRef.hostView.detectChanges();\n    }\n    /** Set any stored initial inputs on the component's properties. */\n    initializeInputs() {\n        for (const [propName, value] of this.initialInputValues) {\n            this.setInputValue(propName, value);\n        }\n        this.initialInputValues.clear();\n    }\n    /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n    initializeOutputs(componentRef) {\n        const eventEmitters = this.componentFactory.outputs.map(({ propName, templateName }) => {\n            const emitter = componentRef.instance[propName];\n            return new Observable((observer) => {\n                const sub = emitter.subscribe((value) => observer.next({ name: templateName, value }));\n                return () => sub.unsubscribe();\n            });\n        });\n        this.eventEmitters.next(eventEmitters);\n    }\n    /** Runs in the angular zone, if present. */\n    runInZone(fn) {\n        return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(fn) : fn();\n    }\n}\n\n/**\n * Implements the functionality needed for a custom element.\n *\n * @publicApi\n */\nclass NgElement extends HTMLElement {\n    /**\n     * A subscription to change, connect, and disconnect events in the custom element.\n     */\n    ngElementEventsSubscription = null;\n}\n/**\n *  @description Creates a custom element class based on an Angular component.\n *\n * Builds a class that encapsulates the functionality of the provided component and\n * uses the configuration information to provide more context to the class.\n * Takes the component factory's inputs and outputs to convert them to the proper\n * custom element API and add hooks to input changes.\n *\n * The configuration's injector is the initial injector set on the class,\n * and used by default for each created instance.This behavior can be overridden with the\n * static property to affect all newly created instances, or as a constructor argument for\n * one-off creations.\n *\n * @see [Angular Elements Overview](guide/elements \"Turning Angular components into custom elements\")\n *\n * @param component The component to transform.\n * @param config A configuration that provides initialization information to the created class.\n * @returns The custom-element construction class, which can be registered with\n * a browser's `CustomElementRegistry`.\n *\n * @publicApi\n */\nfunction createCustomElement(component, config) {\n    const inputs = getComponentInputs(component, config.injector);\n    const strategyFactory = config.strategyFactory || new ComponentNgElementStrategyFactory(component, config.injector);\n    const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);\n    class NgElementImpl extends NgElement {\n        injector;\n        // Work around a bug in closure typed optimizations(b/79557487) where it is not honoring static\n        // field externs. So using quoted access to explicitly prevent renaming.\n        static ['observedAttributes'] = Object.keys(attributeToPropertyInputs);\n        get ngElementStrategy() {\n            // TODO(andrewseguin): Add e2e tests that cover cases where the constructor isn't called. For\n            // now this is tested using a Google internal test suite.\n            if (!this._ngElementStrategy) {\n                const strategy = (this._ngElementStrategy = strategyFactory.create(this.injector || config.injector));\n                // Re-apply pre-existing input values (set as properties on the element) through the\n                // strategy.\n                // TODO(alxhub): why are we doing this? this makes no sense.\n                inputs.forEach(({ propName, transform, isSignal }) => {\n                    if (!this.hasOwnProperty(propName) || isSignal) {\n                        // No pre-existing value for `propName`, or a signal input.\n                        return;\n                    }\n                    // Delete the property from the instance and re-apply it through the strategy.\n                    const value = this[propName];\n                    delete this[propName];\n                    strategy.setInputValue(propName, value, transform);\n                });\n            }\n            return this._ngElementStrategy;\n        }\n        _ngElementStrategy;\n        constructor(injector) {\n            super();\n            this.injector = injector;\n        }\n        attributeChangedCallback(attrName, oldValue, newValue, namespace) {\n            const [propName, transform] = attributeToPropertyInputs[attrName];\n            this.ngElementStrategy.setInputValue(propName, newValue, transform);\n        }\n        connectedCallback() {\n            // For historical reasons, some strategies may not have initialized the `events` property\n            // until after `connect()` is run. Subscribe to `events` if it is available before running\n            // `connect()` (in order to capture events emitted during initialization), otherwise subscribe\n            // afterwards.\n            //\n            // TODO: Consider deprecating/removing the post-connect subscription in a future major version\n            //       (e.g. v11).\n            let subscribedToEvents = false;\n            if (this.ngElementStrategy.events) {\n                // `events` are already available: Subscribe to it asap.\n                this.subscribeToEvents();\n                subscribedToEvents = true;\n            }\n            this.ngElementStrategy.connect(this);\n            if (!subscribedToEvents) {\n                // `events` were not initialized before running `connect()`: Subscribe to them now.\n                // The events emitted during the component initialization have been missed, but at least\n                // future events will be captured.\n                this.subscribeToEvents();\n            }\n        }\n        disconnectedCallback() {\n            // Not using `this.ngElementStrategy` to avoid unnecessarily creating the `NgElementStrategy`.\n            if (this._ngElementStrategy) {\n                this._ngElementStrategy.disconnect();\n            }\n            if (this.ngElementEventsSubscription) {\n                this.ngElementEventsSubscription.unsubscribe();\n                this.ngElementEventsSubscription = null;\n            }\n        }\n        subscribeToEvents() {\n            // Listen for events from the strategy and dispatch them as custom events.\n            this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe((e) => {\n                const customEvent = new CustomEvent(e.name, { detail: e.value });\n                this.dispatchEvent(customEvent);\n            });\n        }\n    }\n    // Add getters and setters to the prototype for each property input.\n    inputs.forEach(({ propName, transform }) => {\n        Object.defineProperty(NgElementImpl.prototype, propName, {\n            get() {\n                return this.ngElementStrategy.getInputValue(propName);\n            },\n            set(newValue) {\n                this.ngElementStrategy.setInputValue(propName, newValue, transform);\n            },\n            configurable: true,\n            enumerable: true,\n        });\n    });\n    return NgElementImpl;\n}\n\n/**\n * @publicApi\n */\nconst VERSION = new Version('19.0.0');\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the `elements` package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgElement, VERSION, createCustomElement };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}